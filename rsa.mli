(*all the rsa computation, using the congruence module,
  in addition to prime generation*)


(*[gen_private_key] is a randomly generated private_key with very high
  probability *)
 val gen_private_key: unit -> Types.value

(*[get_public_key k] is the RSA public key associated with
  private key k*)
val get_public_key: Types.private_key -> Types.value

(*[encrypt k s] is the integer generated by encoding string s
  with RSA public key k*)
 val encrypt: Types.public_key -> string -> Types.value

(*[decrypt k i] is the string s, where i is the result of
  [encrypt k's] with k' being the public key coresponding to
  private key k*)
 val decrypt: Types.private_key -> Types.integer -> Types.value

(*[crack k i] is some s, where i is the result of [encrypt k s]
  this could take a very long time if i can not be factored quickly*)
 val crack: Types.public_key -> Types.integer -> Types.value
